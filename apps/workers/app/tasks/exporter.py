# Created automatically by Cursor AI (2024-12-19)

from typing import Dict, Any, List
from datetime import datetime
from pydantic import BaseModel
from celery import shared_task
import base64
import io
import zipfile

class ExportRequest(BaseModel):
    incident_id: str
    export_type: str  # pdf|csv|mdx|zip
    filename: str
    content: str | None = None
    rows: List[Dict[str, Any]] | None = None

class ExportResponse(BaseModel):
    export_type: str
    filename: str
    mime_type: str
    content_base64: str
    generated_at: str

@shared_task(bind=True, name="export_generate")
def export_generate(self, req: Dict[str, Any]) -> Dict[str, Any]:
    data = ExportRequest(**req)

    if data.export_type == 'csv':
        csv_lines = []
        rows = data.rows or []
        if rows:
            headers = list(rows[0].keys())
            csv_lines.append(','.join(headers))
            for r in rows:
                csv_lines.append(','.join(str(r.get(h, '')) for h in headers))
        else:
            csv_lines = ['id,title,status', '1,Sample,ok']
        content_bytes = ('\n'.join(csv_lines)).encode('utf-8')
        mime = 'text/csv'
        filename = data.filename if data.filename.endswith('.csv') else f"{data.filename}.csv"

    elif data.export_type == 'mdx':
        mdx = data.content or '# Export\nGenerated content.'
        content_bytes = mdx.encode('utf-8')
        mime = 'text/mdx'
        filename = data.filename if data.filename.endswith('.mdx') else f"{data.filename}.mdx"

    elif data.export_type == 'pdf':
        # Stub: simple PDF placeholder (not a real PDF renderer)
        placeholder = f"PDF EXPORT\n{data.content or ''}"
        content_bytes = placeholder.encode('utf-8')
        mime = 'application/pdf'
        filename = data.filename if data.filename.endswith('.pdf') else f"{data.filename}.pdf"

    elif data.export_type == 'zip':
        buffer = io.BytesIO()
        with zipfile.ZipFile(buffer, 'w', zipfile.ZIP_DEFLATED) as zf:
            zf.writestr('README.txt', 'Crisis Packet\nGenerated by exporter')
            if data.content:
                zf.writestr('content.mdx', data.content)
        content_bytes = buffer.getvalue()
        mime = 'application/zip'
        filename = data.filename if data.filename.endswith('.zip') else f"{data.filename}.zip"

    else:
        raise ValueError('Unsupported export_type')

    resp = ExportResponse(
        export_type=data.export_type,
        filename=filename,
        mime_type=mime,
        content_base64=base64.b64encode(content_bytes).decode('utf-8'),
        generated_at=datetime.utcnow().isoformat(),
    )
    return resp.dict()
